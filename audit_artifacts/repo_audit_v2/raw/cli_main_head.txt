# src/firsttry/cli.py
from __future__ import annotations

import argparse
import asyncio
import os
import subprocess
import sys
import types

# sync_with_ci is imported lazily in cmd_sync to avoid optional deps at module import
# Imports for DAG-run helper placed at top to satisfy linters (safe/eager import)
from pathlib import Path
from typing import Any

import click

from firsttry.check_registry import CHECK_REGISTRY as CHECKS_BY_ID
from firsttry.planner.dag import Plan, Task
from firsttry.run_swarm import run_plan

from . import __version__
from .agent_manager import SmartAgentManager

# CI parity runner (lock-file based parity system)
from .ci_parity import parity_runner as ci_runner

try:
    from .ci_parity.cache_utils import (
        auto_refresh_golden_cache,
        clear_cache,
        update_cache,
    )
except ImportError:
    # Fallback if cache_utils not available
    def auto_refresh_golden_cache(fetch_ref: str = "origin/main") -> None:
        pass

    def update_cache(remote_fingerprint: str | None = None) -> None:
        pass

    def clear_cache() -> None:
        pass


from .config_cache import plan_from_config_with_timeout
from .config_loader import apply_overrides_to_plan, load_config
from .context_builders import build_context, build_repo_profile
from .license_guard import get_tier
from .repo_rules import plan_checks_for_repo

# add these imports for old enhanced handlers
# Consolidated CLI handlers migrated from cli_enhanced_old.py


# Auto-parity bootstrap helpers
def _in_git_repo(root: Path) -> bool:
    """Check if directory is a Git repository."""
    return (root / ".git").exists()


def _has_parity_lock(root: Path) -> bool:
    """Check if ci/parity.lock.json exists."""
    return (root / "ci" / "parity.lock.json").exists()


def _parity_bootstrapped(root: Path) -> bool:
    """Check if parity environment is already bootstrapped."""
    return (root / ".venv-parity" / "bin" / "python").exists()


def _auto_parity_enabled() -> bool:
    """Check if auto-parity is enabled (opt-out for end-users/CI)."""
    return os.getenv("FIRSTTRY_DISABLE_AUTO_PARITY") not in ("1", "true", "yes")


def _run(cmd: list[str], **kw: Any) -> None:
    """Run command and raise on failure."""
    subprocess.run(cmd, check=True, **kw)


def _ensure_parity(root: Path) -> None:
    """Auto-bootstrap parity environment and install hooks on first run."""
    if not _auto_parity_enabled():
        return
    if not _in_git_repo(root) or not _has_parity_lock(root):
        return

    # Skip in CI if it has its own bootstrap workflow
    if os.getenv("CI") == "true":
        return

    # Bootstrap venv once
    venv_exists = _parity_bootstrapped(root)
    if not venv_exists:
        print("[firsttry] Setting up parity environmentâ€¦", file=sys.stderr)
        bootstrap_script = root / "scripts" / "ft-parity-bootstrap.sh"
        if bootstrap_script.exists():
            _run([str(bootstrap_script)])
        else:
